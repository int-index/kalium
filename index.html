<!doctype html>
<html>
    <head>
        <link href='http://fonts.googleapis.com/css?family=Ubuntu:700|Droid+Serif:400,700&subset=latin,greek' rel='stylesheet' type='text/css'>
        <style>
            body {
                font-family: 'Droid Serif', serif;
            }
            main {
                width: 70%;
                margin-left: auto;
                margin-right: auto;
            }
            h1, h2 {
                font-family: 'Ubuntu', sans-serif;
            }
            h2 {
                clear: both;
                margin-top: 2em;
            }
            footer {
                text-align: center;
            }
            .logo {
                width: 10em;
                float: left;
            }
            table {
                margin-left: auto;
                margin-right: auto;
                border-collapse: collapse;
            }
            .source {
                padding: 1em;
                border: thin solid #EEEEEE;
                vertical-align: top;
            }
            tfoot {
                font-size: x-small;
                text-align: center;
            }
        </style>
        <title>Kalium</title>
    </head>
    <body>
    <main>
        <img src="sodium.png" class="logo"/>
        <h1>Kalium</h1>
        <p>
            Kalium is a research project. The goal is to generate idiomatic
            functional code from imperative code. The source language is
            <strong>Pascal</strong> (because it's easy to implement), and the
            target language is <strong>Haskell</strong> (because it's powerful).
        </p>

        <p>
            The translator itself is written in Haskell and hosted on
            <a href="https://github.com/int-index/kalium">GitHub</a>.
            Contributions are welcome, so feel free to open an issue
            or create a pull request.
        </p>

        <p>
            The name of the project was changed from Sodium to Kalium due to
            multiple name collisions with other projects.
        </p>

        <h2>Why bother?</h2>
        <p>
            There are reasons to believe that functional paradigm is superior.
            The incomplete list being:
            <ul>
                <li>
                    Code becomes more concise and flexible&mdash;thanks to
                    higher order functions.
                </li>
                <li>
                    Strong static typing helps to prevent bugs, but
                    doesn't get in the way.
                </li>
                <li>
                    The lack of implicit state means that code is way eaiser
                    to reason about and maintain.
                </li>
                <li>
                    Procedural/object-oriented concepts are embeddable
                    using modern techniques (state monad, lenses).
                </li>
                <li>
                    Parallel and concurrent algorithms are way easier to
                    implement.
                </li>
            </ul>
        </p>
        <p>
            Yet there's an unresolved question: what do we do with the
            existing codebase? Billions of lines of code are written in
            imperative languages.
            Manually rewriting every library is extremely tedious
            and can introduce new bugs.
        </p>

        <h2>The problem</h2>
        <p>
            Functional programming is based on Î»-calculus, whereas
            imperative programming takes Turing-machine model as its basis.
            But these are <strong>equivalent</strong>&mdash;for every program
            there's a direct translation from one model to another.
        </p>
        <p>
            The actual problem is not the translation itself, but preserving
            the higher-order abstractions. And this is really difficult
            (probably impossible) to accomplish, as those abstractions
            live inside the programmer's head, not in the code.

            However, the code contains various reflections of those
            abstractions (such as functions and data types), so there should
            be a way to extract some information and use it to translate
            the program.
        </p>

        <h2>The solution</h2>
        <p>
            There's no obvious solution for this problem.
            <strong>Kalium</strong> aims to discover how far we can get. The
            core idea is pattern recognition. Numerous application
            of semantics-preserving transformations to the code can yield
            certain patterns, from which it is possible to extract high-level
            concepts.
        </p>
        <p> The current roadmap is:
            <ol>
                <li>
                    Translate a simple imperative language to a functional
                    language. The output code may not be beautiful/idiomatic.
                </li>
                <li>
                    Find the ways to recover the initial quality of the
                    input code, so the output is at least as good as the input.
                </li>
                <li>
                    Discover the possibilities to make the resulting code
                    better than original (e.g. automatic parallelization).
                </li>
            </ol>
        </p>
        <h2>Example</h2>
        <table>
            <thead>
                <tr>
                    <th> Pascal  </th>
                    <th> Haskell </th>
                </tr>
            </thead>

            <tbody>
                <tr>
                    <td class="source">
<pre>
function f(a: LongInt): LongInt;
var
    i: Integer;
begin
    f := 0;
    for i := 1 to a do begin
        f := f;
        f := f + i;
    end;
end;

var
    k: LongInt;
    trash: Boolean;
    i, n: Integer;
begin
    ReadLn(n);
    k := 1;
    trash := True;
    for i := 1 to n do begin
        k := k * i;
    end;
    k := f(k);
    WriteLn(k);
end.
</pre>
                    </td>
                    <td class="source">
<pre>
main :: IO ()
main
  = do n :: Int &lt;- readLn
       print (f (product [1 .. n]))

f :: Int -&gt; Int
f (a :: Int) = sum [1 .. a]
</pre>
                    </td>
                </tr>
            </tbody>
            <tfoot>
                <tr>
                    <td colspan="2">
                        the code above was translated using Kalium
                    </td>
                </tr>
            </tfoot>
        </table>
        <p>
            <a href="https://int-index.github.io/kalium/examples.html">
                More examples
            </a>
        </p>
        <h2>Can I help?</h2>
        <p>
            Sure! Fork the repo and do whatever you think is good, then create
            a pull request. If you don't know what to do&mdash;my email
            address can be found in commits&mdash;feel free to contact me.
        </p>
        <p>
            Another way to contribute is to use Kalium and find its bugs, file
            feature requests, etc. These may come in handy:
            <ul>
                <li><a href="https://github.com/int-index/kalium/blob/master/README.md">Building instructions</a></li>
                <li><a href="https://int-index.github.io/kalium/pascal.pdf">Supported Pascal subset (PDF)</a></li>
                <li><a href="https://github.com/int-index/kalium/tree/master/testing/tests">Tests (example programs)</a></li>
            </ul>
        </p>
        <p>
           I am a student from Russia and I don't get any financial support to
           work on this project, so donation is one more way to help me.
        </p>

    </main>
    <footer>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----
">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
<img alt="" border="0" src="https://www.paypalobjects.com/ru_RU/i/scr/pixel.gif" width="1" height="1">
</form>
<br>
        <a href="https://github.com/int-index">Index Int</a>, 2014&ndash;2015
    </footer>
    </body>
</html>
